package drx.aws.crypto;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Map;
import java.util.HashMap;
import java.util.Properties;
import java.util.concurrent.*;
import org.apache.commons.codec.binary.Base64;

import com.amazonaws.auth.AWSCredentials;
import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.services.kms.AWSKMS;
import com.amazonaws.services.kms.AWSKMSClient;
import com.amazonaws.services.kms.model.*;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.RemovalListener;
import com.google.common.cache.RemovalNotification;

/**
* Wrapper for using AWS KMS as a keystore to perform envelope encryption. 
* Security benefits over a local keystore include:
* 1) Master keys are not stored on local server
* 2) Multiple clients can use the same keys
* 3) Access keys to KMS can be revoked from AWS console
* @author David Rabb
*/
public class KMS {
  public static final int CACHE_EXPIRY = 10; // maximum age of cached elements in minutes
  public static final String KEYSPEC = "AES_256";
  

  private static Properties properties; 
  
  private static Cache<String,byte[]> cache;
  private static CacheCleaner cacheCleaner;
  
  static {
    init();
  }
  
  /* load kms.properties file */
  private static void init() {
    try {
      properties = new Properties();
      properties.load(KMS.class.getResourceAsStream("/kms.properties"));
      
      RemovalListener<String,byte[]> removalListener = new RemovalListener<String,byte[]>() {
        @Override
        public void onRemoval(RemovalNotification<String,byte[]> removal) {
          zeroArray(removal.getValue()); // make an attempt to clear sensitive key data from memory
        }
      };
      cache = CacheBuilder.newBuilder()
          .expireAfterWrite(CACHE_EXPIRY, TimeUnit.MINUTES)
          .removalListener(removalListener)
          .build();
      
      cacheCleaner = new CacheCleaner(cache);
      
    } catch(IOException e) {
      throw new RuntimeException(e);
    }
  }

  /* Generate new permanent data key in KMS using a friendly name for the key.
   * return base64-encoded (url safe) string of the data key ID generated by KMS.
   * Friendly name and KMS key ID to be stored in kms.properties file. Actual key is stored in KMS.
   * The properties file translates friendly key names/topics to the long, ugly KMS key IDs.
   */
  public static final String generateDataKey(String keyName) throws IOException {
    AWSKMS kms = getClient();
    GenerateDataKeyWithoutPlaintextRequest dataKeyRequest = new GenerateDataKeyWithoutPlaintextRequest();
    dataKeyRequest.setKeyId(properties.getProperty("masterKey"));
    dataKeyRequest.setKeySpec(KEYSPEC);
    dataKeyRequest.setEncryptionContext(contextForName(keyName));
    
    GenerateDataKeyWithoutPlaintextResult dataKeyResult = kms.generateDataKeyWithoutPlaintext(dataKeyRequest);
    byte[] dataKeyValue = new byte[dataKeyResult.getCiphertextBlob().remaining()];
    dataKeyResult.getCiphertextBlob().get(dataKeyValue);
    return Base64.encodeBase64URLSafeString(dataKeyValue);
  }
  
  /* get cached data key or retrieve from KMS */
  private static byte[] getDataKey(final String keyName) {
    //System.out.println(contextForName(keyName));
    try {
      byte[] encryptionKey = cache.get(keyName, new Callable<byte[]>() {
          @Override
          public byte[] call() {
            return fetchDataKey(keyName);
          }
        });
      return encryptionKey;
    } catch(ExecutionException e) {
      throw new RuntimeException(e);
    }
  }
  
  /* get cached data key or retrieve from KMS */
  private static byte[] fetchDataKey(String keyName) {
    try {
      String dataKeyValue = properties.getProperty(keyName);
      if (dataKeyValue==null) throw new IOException("Key ("+keyName+") not found in kms.properties");
      ByteBuffer keyIdBuffer = ByteBuffer.wrap(Base64.decodeBase64(dataKeyValue));
      DecryptRequest req = new DecryptRequest().withCiphertextBlob(keyIdBuffer);
      req.setEncryptionContext(contextForName(keyName));
      AWSKMS kms = getClient();
      DecryptResult result = kms.decrypt(req);
      byte[] encryptionKey = new byte[result.getPlaintext().remaining()];
      result.getPlaintext().get(encryptionKey);
      cache.put(keyName, encryptionKey);
      return encryptionKey;
    } catch(IOException e) {
      throw new RuntimeException(e);
    }
  }
  
  /* overwrite byte array with zeros rather than simply removing from cache */
  private static void zeroArray(byte[] b) {
    for (int i=0; b!=null && i<b.length; i++) {
      b[i] = 0;
    }
  }
  
  /* given master key id and data key name in properties file, get key from KMS then encrypt */
  public static final String encrypt(String plaintextData, String keyName) {
    byte[] encryptionKey = getDataKey(keyName);
    return AES.encrypt(plaintextData, encryptionKey);
  }
  
  /* given master key id in properties file and kms datakey, decrypt a dataset containing algorithm, text encoding, IV and data */
  public static final String decrypt(String encryptedDataSet, String keyName)  {
    byte[] encryptionKey = getDataKey(keyName);
    return AES.decrypt(encryptedDataSet, encryptionKey);
  }

  private static AWSKMS getClient() throws IOException {
    AWSCredentials credentials = new BasicAWSCredentials(
        properties.getProperty("accessKey"), properties.getProperty("secretKey"));
    AWSKMSClient kms = new AWSKMSClient(credentials);
    kms.setEndpoint(properties.getProperty("endPoint"));
    return kms;
  }
  
  /* Put keyName in encryption context wrapper for audit trail */
  private static Map contextForName(String keyName) {
    Map map = new HashMap();
    map.put("data-key", keyName);
    return map;
  }
  
}

/* Since Guava only invalidates expired items on access, we need to create 
 * a separate execution thread to make sure stale keys are only stored temporarily.
*/
class CacheCleaner {
  private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
  private final Cache _cache;

  public CacheCleaner(Cache cache) {
    this._cache = cache;
    
    final Runnable cleaner = new Runnable() {
      @Override
      public void run() {
        _cache.cleanUp();
      }
    };
    final ScheduledFuture handle = scheduler.scheduleAtFixedRate(
            cleaner, 1, 1, TimeUnit.MINUTES
    );
  }
}

